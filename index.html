<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Smart Code Surgeon - Intelligent Context-Aware Patching</title>
<style>
  :root { 
    --bg:#0a0e17; 
    --panel:#0d1117; 
    --panel-border:#1b2332;
    --text:#e6edf3; 
    --muted:#7d8590; 
    --accent:#2f81f7; 
    --success:#3fb950;
    --warning:#d29922;
    --danger:#f85149;
    --purple:#a371f7;
    --mono: ui-monospace,SFMono-Regular,"SF Mono",Consolas,"Liberation Mono",Menlo,monospace;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: var(--bg); color: var(--text); font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif; line-height: 1.5; }
  header { background: linear-gradient(to bottom, #0d1117 0%, #0a0e17 100%); border-bottom: 1px solid var(--panel-border); padding: 20px 24px; }
  header h1 { font-size: 20px; font-weight: 600; margin-bottom: 4px; }
  .subtitle { color: var(--muted); font-size: 14px; }
  .container { max-width: 1400px; margin: 0 auto; padding: 24px; }
  .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
  .panel { background: var(--panel); border: 1px solid var(--panel-border); border-radius: 12px; padding: 20px; }
  .panel h2 { font-size: 16px; font-weight: 600; margin-bottom: 16px; display: flex; align-items: center; gap: 8px; }
  .form-group { margin-bottom: 16px; }
  label { display: block; font-size: 13px; font-weight: 500; color: var(--muted); margin-bottom: 6px; }
  input[type="text"], input[type="number"], select, textarea {
    width: 100%; background: #010409; border: 1px solid var(--panel-border); border-radius: 6px; color: var(--text);
    font-family: var(--mono); font-size: 13px; padding: 8px 12px; transition: border-color 0.2s;
  }
  input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); }
  textarea { min-height: 150px; resize: vertical; }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
  .actions { display: flex; gap: 12px; margin-top: 20px; flex-wrap: wrap; }
  button { background: var(--panel-border); border: 1px solid transparent; border-radius: 6px; color: var(--text); cursor: pointer; font-size: 14px; font-weight: 500; padding: 8px 16px; transition: all 0.2s; }
  button:hover { background: #1f2937; border-color: var(--accent); }
  button:active { transform: translateY(1px); }
  button.primary { background: var(--accent); color: white; }  button.primary:hover { background: #388bfd; }
  button.success { background: var(--success); color: white; }  button.success:hover { background: #46c456; }
  button.danger { background: var(--danger); color: white; }   button.danger:hover { background: #ff6b5d; }
  .status { margin-top: 16px; padding: 12px; border-radius: 6px; font-size: 13px; display: flex; align-items: center; gap: 8px; }
  .status.info { background: rgba(47, 129, 247, 0.1); border: 1px solid rgba(47, 129, 247, 0.3); color: var(--accent); }
  .status.success { background: rgba(63, 185, 80, 0.1); border: 1px solid rgba(63, 185, 80, 0.3); color: var(--success); }
  .status.warning { background: rgba(210, 153, 34, 0.1); border: 1px solid rgba(210, 153, 34, 0.3); color: var(--warning); }
  .status.error { background: rgba(248, 81, 73, 0.1); border: 1px solid rgba(248, 81, 73, 0.3); color: var(--danger); }
  .language-badge { display: inline-block; background: var(--purple); color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; text-transform: uppercase; }
  .detection-info { background: rgba(163, 113, 247, 0.1); border: 1px solid rgba(163, 113, 247, 0.3); border-radius: 6px; padding: 12px; margin-bottom: 16px; font-size: 13px; }
  .detection-info strong { color: var(--purple); }
  pre { background: #010409; border: 1px solid var(--panel-border); border-radius: 6px; padding: 12px; overflow: auto; max-height: 400px; }
  code { font-family: var(--mono); font-size: 12px; line-height: 1.5; }
  .hint { color: var(--muted); font-size: 12px; margin-top: 4px; }
  .checkbox-group { display: flex; gap: 20px; margin: 16px 0; }
  .checkbox-item { display: flex; align-items: center; gap: 8px; }
  .checkbox-item input { width: 16px; height: 16px; }
  .checkbox-item label { margin: 0; font-size: 13px; cursor: pointer; }
  .detected-languages { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
  .confidence-meter { display: flex; align-items: center; gap: 8px; margin-top: 8px; }
  .confidence-bar { flex: 1; height: 8px; background: var(--panel-border); border-radius: 4px; overflow: hidden; }
  .confidence-fill { height: 100%; background: linear-gradient(to right, var(--danger), var(--warning), var(--success)); transition: width 0.3s; }
  @media (max-width: 768px) { .grid, .row { grid-template-columns: 1fr; } }
</style>
</head>
<body>
  <header>
    <h1>üß¨ Smart Code Surgeon</h1>
    <div class="subtitle">Intelligent language detection with guaranteed valid comment syntax</div>
  </header>

  <div class="container">
    <div class="grid">
      <div class="panel">
        <h2>üìù Input Configuration</h2>
        <div class="detection-info" id="detectionInfo">
          <strong>Auto-Detection:</strong> The tool analyzes your code to choose the correct language & comment style.
        </div>

        <div class="row">
          <div class="form-group">
            <label for="filename">Filename (optional)</label>
            <input type="text" id="filename" placeholder="e.g., script.js or main.py">
            <div class="hint">Strongly recommended‚Äîespecially for mixed files (like HTML with embedded JS/CSS or PHP)</div>
          </div>
          <div class="form-group">
            <label for="forceLanguage">Override Language</label>
            <select id="forceLanguage">
              <option value="auto">Auto-detect (recommended)</option>
              <option value="javascript">JavaScript/TypeScript</option>
              <option value="python">Python</option>
              <option value="java">Java</option>
              <option value="cpp">C/C++</option>
              <option value="csharp">C#</option>
              <option value="go">Go</option>
              <option value="rust">Rust</option>
              <option value="ruby">Ruby</option>
              <option value="php">PHP</option>
              <option value="swift">Swift</option>
              <option value="kotlin">Kotlin</option>
              <option value="html">HTML/XML</option>
              <option value="css">CSS</option>
              <option value="sql">SQL</option>
              <option value="shell">Shell/Bash</option>
              <option value="lua">Lua</option>
              <option value="r">R</option>
            </select>
          </div>
        </div>

        <div class="checkbox-group">
          <div class="checkbox-item"><input type="checkbox" id="preserveIndent" checked><label for="preserveIndent">Preserve indentation</label></div>
          <div class="checkbox-item"><input type="checkbox" id="useBlockComments"><label for="useBlockComments">Use block comments when available</label></div>
          <div class="checkbox-item"><input type="checkbox" id="validateSyntax" checked><label for="validateSyntax">Validate output syntax</label></div>
        </div>

        <div class="form-group">
          <label for="baseCode">Original Code</label>
          <textarea id="baseCode" placeholder="Paste your complete code file here..."></textarea>
        </div>

        <div class="row">
          <div class="form-group">
            <label for="targetCode">Code to Replace</label>
            <textarea id="targetCode" placeholder="Paste the section you want to replace..."></textarea>
          </div>
          <div class="form-group">
            <label for="newCode">Replacement Code</label>
            <textarea id="newCode" placeholder="Paste the new code..."></textarea>
          </div>
        </div>

        <div class="row">
          <div class="form-group">
            <label for="threshold">Match Threshold</label>
            <input type="number" id="threshold" value="0.6" min="0" max="1" step="0.05">
            <div class="hint">Higher = stricter matching (0.6 recommended)</div>
          </div>
          <div class="form-group">
            <label for="contextLines">Context Lines</label>
            <input type="number" id="contextLines" value="3" min="0" max="10">
            <div class="hint">Lines of flexibility for fuzzy matching</div>
          </div>
        </div>

        <div class="actions">
          <button id="detectBtn">üîç Detect Language</button>
          <button id="findBtn">üéØ Find Match</button>
          <button id="patchBtn" class="primary">‚ö° Apply Patch</button>
          <button id="downloadBtn" class="success">üíæ Download</button>
          <button id="clearBtn" class="danger">üóëÔ∏è Clear All</button>
        </div>

        <div id="status"></div>
      </div>

      <div class="panel">
        <h2>üëÅÔ∏è Preview & Analysis</h2>
        <div id="languageInfo" style="display:none;">
          <label>Detected Language</label>
          <div class="detected-languages" id="detectedLanguages"></div>
          <div class="confidence-meter">
            <span>Confidence:</span>
            <div class="confidence-bar"><div class="confidence-fill" id="confidenceFill"></div></div>
            <span id="confidenceText">0%</span>
          </div>
        </div>
        <div class="form-group"><label>Match Result</label><div id="matchInfo" class="hint">No match performed yet</div></div>
        <div class="form-group"><label>Output Preview</label><pre><code id="preview">// Your patched code will appear here</code></pre></div>
        <div id="syntaxValidation" style="display:none;">
          <label>Syntax Validation</label>
          <div id="validationResult"></div>
        </div>
      </div>
    </div>
  </div>

<script>
// ---------- small helpers ----------
const el = id => document.getElementById(id);
function setStatus(message, type = 'info') {
  const status = el('status');
  status.className = 'status ' + type;
  status.textContent = message;
  status.style.display = 'block';
}

// Never embed the raw closing tag token in page JS; split or escape it.
function escapeScriptEnd(s){
  // Replace the substring "</script" in user text to "<\/script" safely
  return String(s).replace(new RegExp('<' + '\\/script','gi'), '<\\/script');
}

// ==================== Language Detection Engine ====================
class SmartLanguageDetector {
  constructor() {
    this.signatures = {
      javascript: {
        keywords: /\b(const|let|var|function|async|await|import|export|require|console|document|window|=>|class|extends|constructor|super|this|new|typeof|instanceof|null|undefined|NaN|Infinity)\b/g,
        patterns: [/^\s*import\s+.+\s+from\s+['"]/,/^\s*const\s+\w+\s*=\s*require\(/,/console\.\w+\(/,/\$\(['"]/,/document\.getElementById/,/\.addEventListener\(/,/\{\s*return\s+/,/\=\>/,/\`[\s\S]*\$\{/],
        extensions: ['js','jsx','ts','tsx','mjs','cjs'], weight: 0
      },
      python: {
        keywords: /\b(def|class|import|from|as|if|elif|else|for|while|in|not|and|or|is|None|True|False|self|return|yield|lambda|with|try|except|finally|raise|assert|global|nonlocal|del|pass|break|continue|print|len|range|enumerate|zip|map|filter|sorted|reversed|isinstance|__init__|__name__|__main__)\b/g,
        patterns: [/^\s*def\s+\w+\s*\(/,/^\s*class\s+\w+/,/^\s*from\s+\w+\s+import/,/^\s*import\s+\w+/,/if\s+__name__\s*==\s*['"]__main__['"]/,/:\s*$/m,/^\s{4,}/,/"""/,/print\s*\(/,/\bself\.\w+/],
        extensions: ['py','pyw','pyx','pxd','pxi'], weight: 0
      },
      java: { keywords:/\b(public|private|protected|static|final|abstract|class|interface|extends|implements|import|package|new|this|super|void|int|long|double|float|boolean|char|byte|short|String|if|else|for|while|do|switch|case|break|continue|return|try|catch|finally|throw|throws|synchronized|volatile|transient|native|strictfp|enum|assert|default)\b/g,
        patterns:[/^\s*package\s+[\w\.]+;/,/^\s*import\s+[\w\.]+;/,/public\s+class\s+\w+/,/public\s+static\s+void\s+main/,/System\.out\.print/,/\bnew\s+\w+\(/,/@Override/,/\/\/.*$|\/\*[\s\S]*?\*\//m],
        extensions:['java'], weight:0 },
      cpp: { keywords:/\b(include|define|ifdef|ifndef|endif|pragma|using|namespace|class|struct|enum|union|public|private|protected|virtual|friend|operator|template|typename|typedef|const|static|extern|inline|volatile|register|auto|void|int|long|short|unsigned|signed|float|double|char|bool|wchar_t|if|else|for|while|do|switch|case|break|continue|return|goto|try|catch|throw|new|delete|this|nullptr|true|false|sizeof|typeid|dynamic_cast|static_cast|reinterpret_cast|const_cast)\b/g,
        patterns:[/^\s*#include\s*[<"]/,/^\s*using\s+namespace\s+/,/std::\w+/,/cout\s*<<|cin\s*>>/,/\w+::\w+/,/->/,/template\s*</],
        extensions:['cpp','cc','cxx','c++','h','hpp','hxx'], weight:0 },
      csharp: { keywords:/\b(using|namespace|class|struct|interface|enum|delegate|public|private|protected|internal|static|readonly|const|virtual|override|abstract|sealed|partial|async|await|void|int|long|double|float|decimal|bool|char|string|byte|sbyte|short|ushort|uint|ulong|object|dynamic|var|if|else|for|foreach|while|do|switch|case|break|continue|return|yield|try|catch|finally|throw|new|this|base|null|true|false|is|as|typeof|sizeof|checked|unchecked|default|ref|out|in|params|get|set|value|add|remove|where|select|from|orderby|group|into|join|let|ascending|descending|on|equals|by)\b/g,
        patterns:[/^\s*using\s+\w+;/,/^\s*namespace\s+\w+/,/public\s+class\s+\w+/,/\[[\w\.]+\]/,/Console\.Write/,/\$".*\{.*\}"/,/=>\s*\{?/,/\?\?/,/\?\./],
        extensions:['cs'], weight:0 },
      html: {
        keywords:/\b(DOCTYPE|html|head|body|title|meta|link|script|style|div|span|p|a|img|ul|ol|li|table|tr|td|th|form|input|button|select|option|textarea|header|footer|nav|main|section|article|aside|h1|h2|h3|h4|h5|h6|br|hr|strong|em|code|pre|blockquote|iframe|canvas|svg|video|audio|source|picture)\b/gi,
        patterns:[/<!DOCTYPE\s+html/i,/<html[\s>]/,/<\/\w+>/,/<\w+\s*\/>/,/<!--[\s\S]*?-->/,/class\s*=\s*["']/,/id\s*=\s*["']/,/href\s*=\s*["']/,/src\s*=\s*["']/],
        extensions:['html','htm','xhtml','xml','svg','php'], weight:0
      },
      css: {
        keywords:/\b(important|inherit|initial|unset|auto|none|block|inline|flex|grid|absolute|relative|fixed|sticky|static)\b/gi,
        patterns:[/[.#]\w+\s*\{/,/:\w+\s*\{/,/::\w+\s*\{/,/@media\s+/,/@import\s+/,/\w+:\s*[\w\-]+;/,/rgba?\(/,/hsla?\(/,/calc\(/,/var\(--/],
        extensions:['css','scss','sass','less'], weight:0
      }
    };
    this.commentSyntax = {
      javascript:{ line:'//', block:{ start:'/*', end:'*/' } },
      python:{ line:'#', block:{ start:'"""', end:'"""' } },
      java:{ line:'//', block:{ start:'/*', end:'*/' } },
      cpp:{ line:'//', block:{ start:'/*', end:'*/' } },
      csharp:{ line:'//', block:{ start:'/*', end:'*/' } },
      go:{ line:'//', block:{ start:'/*', end:'*/' } },
      rust:{ line:'//', block:{ start:'/*', end:'*/' } },
      ruby:{ line:'#', block:{ start:'=begin', end:'=end' } },
      php:{ line:'//', block:{ start:'/*', end:'*/' } },
      swift:{ line:'//', block:{ start:'/*', end:'*/' } },
      kotlin:{ line:'//', block:{ start:'/*', end:'*/' } },
      html:{ line:null, block:{ start:'<!--', end:'-->' } },
      css:{ line:null, block:{ start:'/*', end:'*/' } },
      sql:{ line:'--', block:{ start:'/*', end:'*/' } },
      shell:{ line:'#', block:null },
      lua:{ line:'--', block:{ start:'--[[', end:']]' } },
      r:{ line:'#', block:null }
    };
  }

  detectFromContent(code) {
    for (let lang in this.signatures) this.signatures[lang].weight = 0;
    for (let [lang, cfg] of Object.entries(this.signatures)) {
      const keywordMatches = (code.match(cfg.keywords) || []).length;
      cfg.weight += keywordMatches * 2;
      for (let p of cfg.patterns) {
        const m = code.match(p); if (m) cfg.weight += m.length * 5;
      }
    }
    const results = Object.entries(this.signatures)
      .map(([lang,cfg]) => ({ language: lang, weight: cfg.weight }))
      .filter(r => r.weight > 0)
      .sort((a,b)=>b.weight-a.weight);
    if (!results.length) return { language: 'plaintext', confidence: 0 };
    const top = results[0];
    const tot = results.reduce((s,r)=>s+r.weight,0);
    return { language: top.language, confidence: tot? (top.weight/tot):0, alternatives: results.slice(1,3).map(r=>r.language) };
  }

  detectFromExtension(filename) {
    if (!filename) return null;
    const ext = filename.split('.').pop().toLowerCase();
    for (let [lang,cfg] of Object.entries(this.signatures)) {
      if (cfg.extensions && cfg.extensions.includes(ext)) return lang;
    }
    const extMap = { md:'markdown', yml:'yaml', yaml:'yaml', json:'javascript', sh:'shell', bash:'shell', zsh:'shell', rb:'ruby', rs:'rust', go:'go', kt:'kotlin', swift:'swift', r:'r', sql:'sql', lua:'lua', php:'html' };
    return extMap[ext] || null;
  }

  getCommentSyntax(language){ return this.commentSyntax[language] || this.commentSyntax.javascript; }

  // Keep validation minimal & safe (avoid false positives across mixed files)
  validateCommentSyntax(code, language) {
    const issues = [];
    if (language==='python' && /(^|\s)\/\//m.test(code)) issues.push('Found // which is invalid in Python');
    return { valid: issues.length===0, issues };
  }
}

// ==================== Fuzzy Matching Engine ====================
class FuzzyMatcher {
  tokenize(code){ return code.toLowerCase().replace(/[^\w\s{}()[\]<>,.;:'"!@#$%^&*+=|\\/?-]/g,' ').replace(/\s+/g,' ').trim(); }
  createBigrams(s){ const b=[]; for(let i=0;i<s.length-1;i++) b.push(s.slice(i,i+2)); return b; }
  diceSimilarity(a,b){
    const t1=this.tokenize(a), t2=this.tokenize(b); if(!t1||!t2) return 0;
    const B1=this.createBigrams(t1), B2=this.createBigrams(t2); if(!B1.length||!B2.length) return 0;
    const freq=new Map(); for(const g of B1){ freq.set(g,(freq.get(g)||0)+1); }
    let inter=0; for(const g of B2){ const c=freq.get(g)||0; if(c>0){ inter++; freq.set(g,c-1);} }
    return (2*inter)/(B1.length+B2.length);
  }
  findBestMatch(baseLines, targetLines, context=3){
    const targetStr=targetLines.join('\n');
    const baseStr=baseLines.join('\n');
    const idx=baseStr.indexOf(targetStr);
    if(idx!==-1){
      const before=baseStr.slice(0,idx).split('\n').length-1;
      return { score:1.0, start: before, end: before+targetLines.length, content: targetStr, exact:true };
    }
    let best={ score:0, start:0, end:0, content:'', exact:false };
    const minWin=Math.max(1,targetLines.length-context), maxWin=targetLines.length+context;
    for(let w=minWin; w<=maxWin; w++){
      for(let i=0; i<=baseLines.length-w; i++){
        const win=baseLines.slice(i,i+w).join('\n');
        const s=this.diceSimilarity(win,targetStr);
        if(s>best.score) best={score:s,start:i,end:i+w,content:win,exact:false};
      }
    }
    return best;
  }
}

// ==================== Region-aware syntax for mixed files ====================
function regionCommentSyntax(baseLines, detectedLanguage, startLine, detector){
  if (detectedLanguage!=='html' && detectedLanguage!=='php') {
    return detector.getCommentSyntax(detectedLanguage);
  }
  const upto = baseLines.slice(0, Math.max(0, startLine+1)).join('\n').toLowerCase();

  // positions (avoid literal closing token)
  const lastScriptOpen = upto.lastIndexOf('<script');
  const lastScriptClose = upto.lastIndexOf('</' + 'script>');
  const lastStyleOpen  = upto.lastIndexOf('<style');
  const lastStyleClose = upto.lastIndexOf('</' + 'style>');
  const lastPhpOpen    = upto.lastIndexOf('<?php');
  const lastPhpClose   = upto.lastIndexOf('?>');

  const inScript = lastScriptOpen > lastScriptClose;
  const inStyle  = lastStyleOpen  > lastStyleClose;
  const inPhp    = lastPhpOpen    > lastPhpClose;

  if (inPhp)    return detector.commentSyntax.php;
  if (inScript) return detector.commentSyntax.javascript;
  if (inStyle)  return detector.commentSyntax.css;
  return detector.commentSyntax.html;
}

// Escape dangerous closers when we must use block-only comments
function escapeForBlock(language, text){
  if (language === 'html') return text.replace(/-->/g, '--\u200B>');
  // languages with /* ... */ blocks
  if (['javascript','java','cpp','csharp','go','rust','php','kotlin','swift','css','sql'].includes(language)) {
    return text.replace(/\*\//g, '*\\/');
  }
  if (language === 'lua') return text.replace(/\]\]/g, '] ]');
  if (language === 'ruby') return text.replace(/^\s*=end\s*$/gm, ' =end');
  if (language === 'python') return text; // we'll prefer line comments for Python anyway
  return text;
}

// ==================== Main Application ====================
const detector = new SmartLanguageDetector();
const matcher  = new FuzzyMatcher();
let currentMatch = null;
let detectedLanguage = null;

function showLanguageInfo(language, confidence, alternatives){
  const info = el('languageInfo'), langs = el('detectedLanguages'), bar = el('confidenceFill'), txt = el('confidenceText');
  info.style.display='block';
  langs.innerHTML = `<span class="language-badge">${language}</span>`;
  if (alternatives?.length){ for (const alt of alternatives) langs.innerHTML += ` <span class="language-badge" style="opacity:.6">${alt}</span>`; }
  const pct = Math.round(confidence*100); bar.style.width = pct+'%'; txt.textContent = pct+'%';
}

function detectLanguage(){
  const code = el('baseCode').value;
  const filename = el('filename').value.trim();
  const forced = el('forceLanguage').value;

  if(!code.trim()){ setStatus('Please enter some code to analyze','warning'); return; }

  if(forced!=='auto'){
    detectedLanguage = forced;
    showLanguageInfo(forced,1.0,[]);
    setStatus(`Using specified language: ${forced}`,'success');
    return;
  }

  const contentRes = detector.detectFromContent(code);
  const extLang = filename ? detector.detectFromExtension(filename) : null;

  // Prefer extension hint strongly
  if(extLang){
    detectedLanguage = extLang;
    showLanguageInfo(extLang, Math.max(0.8, contentRes.confidence||0.5), contentRes.language?[contentRes.language]:[]);
    setStatus(`Detected ${extLang} from file extension`,'success');
  } else {
    detectedLanguage = contentRes.language || 'plaintext';
    showLanguageInfo(detectedLanguage, contentRes.confidence, contentRes.alternatives);
    setStatus(`Detected ${detectedLanguage} (${Math.round((contentRes.confidence||0)*100)}% confidence)`,'info');
  }
}

function findMatch(){
  const baseCode = el('baseCode').value;
  const targetCode = el('targetCode').value;
  const threshold = parseFloat(el('threshold').value||'0.6');
  const context = parseInt(el('contextLines').value||'3',10);

  if(!baseCode.trim() || !targetCode.trim()){ setStatus('Please enter both base code and target code','warning'); return; }

  const baseLines = baseCode.split('\n');
  const targetLines = targetCode.split('\n');
  currentMatch = matcher.findBestMatch(baseLines, targetLines, context);

  const matchInfo = el('matchInfo');
  if(currentMatch.exact){
    matchInfo.innerHTML = `<strong style="color:var(--success)">Exact match found!</strong> Lines ${currentMatch.start+1}-${currentMatch.end}`;
    setStatus('Perfect match found!','success');
  } else if(currentMatch.score >= threshold){
    matchInfo.innerHTML = `<strong style="color:var(--success)">Match found:</strong> ${Math.round(currentMatch.score*100)}% similarity at lines ${currentMatch.start+1}-${currentMatch.end}`;
    setStatus(`Match found with ${Math.round(currentMatch.score*100)}% similarity`,'success');
  } else {
    matchInfo.innerHTML = `<strong style="color:var(--warning)">Weak match:</strong> ${Math.round(currentMatch.score*100)}% similarity at lines ${currentMatch.start+1}-${currentMatch.end}`;
    setStatus(`Weak match: ${Math.round(currentMatch.score*100)}% similarity (below threshold)`,'warning');
  }
  el('preview').textContent = currentMatch.content;
}

// ---- Python-aware block comment guard (don‚Äôt inject triple quotes inside a triple-quoted string) ----
function isInsidePythonTripleQuote(baseLines, startLine){
  const upto = baseLines.slice(0, startLine+1).join('\n');
  const re = /("""|''')/g;
  let m, count = 0;
  while((m = re.exec(upto)) !== null) count++;
  return (count % 2) === 1;
}

function applyPatch(){
  const baseCode = el('baseCode').value;
  const newCode = el('newCode').value;
  let preserveIndent = el('preserveIndent').checked;
  let useBlock = el('useBlockComments').checked;
  const validate = el('validateSyntax').checked;

  if(!baseCode.trim() || !newCode.trim()){ setStatus('Please enter base code and replacement code','warning'); return; }
  if(!currentMatch){ findMatch(); if(!currentMatch){ setStatus('Please find a match first','warning'); return; } }

  if(!detectedLanguage) detectLanguage();

  const baseLines = baseCode.split('\n');

  // If Python and the match is inside a triple-quoted string, force line comments
  if(detectedLanguage==='python' && useBlock && isInsidePythonTripleQuote(baseLines, currentMatch.start)){
    useBlock = false;
  }

  // Region-aware syntax for mixed HTML/PHP files
  const scopedSyntax = regionCommentSyntax(baseLines, detectedLanguage, currentMatch.start, detector);
  const langForScoped = (detectedLanguage==='html' || detectedLanguage==='php')
    ? (scopedSyntax===detector.commentSyntax.javascript ? 'javascript'
       : scopedSyntax===detector.commentSyntax.css ? 'css'
       : scopedSyntax===detector.commentSyntax.php ? 'php'
       : 'html')
    : detectedLanguage;

  // Compute indentation from first matched line
  let indent = '';
  if(preserveIndent && currentMatch.start < baseLines.length){
    const first = baseLines[currentMatch.start];
    const m = first.match(/^(\s*)/); if(m) indent = m[1];
  }

  // Build patch markers (block or line, depending on availability & toggle)
  const ts = new Date().toISOString();
  let beginMarker, endMarker;

  if(useBlock && scopedSyntax.block){
    beginMarker = `${indent}${scopedSyntax.block.start} BEGIN_SURGEON_PATCH ${ts} ${scopedSyntax.block.end}`;
    endMarker   = `${indent}${scopedSyntax.block.start} END_SURGEON_PATCH ${scopedSyntax.block.end}`;
  } else if (scopedSyntax.line){
    beginMarker = `${indent}${scopedSyntax.line} BEGIN_SURGEON_PATCH ${ts}`;
    endMarker   = `${indent}${scopedSyntax.line} END_SURGEON_PATCH`;
  } else if (scopedSyntax.block) {
    // language has only block comments (e.g., html/css/sql)
    beginMarker = `${indent}${scopedSyntax.block.start} BEGIN_SURGEON_PATCH ${ts} ${scopedSyntax.block.end}`;
    endMarker   = `${indent}${scopedSyntax.block.start} END_SURGEON_PATCH ${scopedSyntax.block.end}`;
  } else {
    setStatus('No comment syntax available for this language/region','error'); return;
  }

  // Compose patched text
  const patched = [];
  patched.push(...baseLines.slice(0, currentMatch.start));
  patched.push(beginMarker);

  const newLines = newCode.split('\n');
  for(const line of newLines){
    patched.push(line.length ? (indent + line) : '');
  }

  patched.push(endMarker,'');
  
  // Safely include ORIGINAL code (prefer line comments when possible)
  const originalLines = baseLines.slice(currentMatch.start, currentMatch.end);
  if (scopedSyntax.line) {
    patched.push(`${indent}${scopedSyntax.line} ORIGINAL_CODE (commented):`);
    for(const line of originalLines){
      patched.push(line.length ? `${indent}${scopedSyntax.line} ${line}` : `${indent}${scopedSyntax.line}`);
    }
  } else if (scopedSyntax.block) {
    patched.push(`${indent}${scopedSyntax.block.start} ORIGINAL_CODE:`);
    const escaped = escapeForBlock(langForScoped, originalLines.join('\n')).split('\n');
    for(const line of escaped){
      patched.push(indent + ' ' + line);
    }
    patched.push(`${indent}${scopedSyntax.block.end}`);
  }

  patched.push(...baseLines.slice(currentMatch.end));

  const patchedCode = patched.join('\n');

  // Validate if requested
  if(validate){
    const val = detector.validateCommentSyntax(patchedCode, langForScoped);
    const box = el('syntaxValidation'), out = el('validationResult');
    box.style.display='block';
    out.innerHTML = val.valid
      ? '<span style="color:var(--success)">‚úì Valid syntax for '+langForScoped+'</span>'
      : '<span style="color:var(--danger)">‚úó Syntax issues: '+escapeScriptEnd(val.issues.join(', '))+'</span>';
  }

  el('preview').textContent = patchedCode; // use textContent (never innerHTML) for safety
  window.patchedCode = patchedCode;
  setStatus('Patch applied successfully! Review the preview and download when ready.','success');
}

function downloadResult(){
  if(!window.patchedCode){ setStatus('No patched code to download. Apply a patch first.','warning'); return; }
  const filename = el('filename').value || 'patched_code.txt';
  const blob = new Blob([window.patchedCode], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename.includes('.') ? filename.replace(/\.(?=[^.]+$)/, '.patched.') : (filename + '.patched');
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  URL.revokeObjectURL(url);
  setStatus('File downloaded successfully!','success');
}

function clearAll(){
  if(!confirm('Clear all fields? This cannot be undone.')) return;
  el('baseCode').value=''; el('targetCode').value=''; el('newCode').value=''; el('filename').value='';
  el('preview').textContent='// Your patched code will appear here';
  el('matchInfo').textContent='No match performed yet';
  el('languageInfo').style.display='none'; el('syntaxValidation').style.display='none'; el('status').style.display='none';
  currentMatch=null; detectedLanguage=null; window.patchedCode=null;
  setStatus('All fields cleared','info');
}

// --- Button bindings (no inline JS)
el('detectBtn').addEventListener('click', detectLanguage);
el('findBtn').addEventListener('click', findMatch);
el('patchBtn').addEventListener('click', applyPatch);
el('downloadBtn').addEventListener('click', downloadResult);
el('clearBtn').addEventListener('click', clearAll);

// --- Demo data (kept simple; safe literals)
el('baseCode').value = `function calculateSum(numbers) {
  let total = 0;
  for (let i = 0; i < numbers.length; i++) {
    total += numbers[i];
  }
  return total;
}

const result = calculateSum([1, 2, 3, 4, 5]);
console.log('Sum:', result);`;

el('targetCode').value = `function calculateSum(numbers) {
  let total = 0;
  for (let i = 0; i < numbers.length; i++) {
    total += numbers[i];
  }
  return total;
}`;

el('newCode').value = `function calculateSum(numbers) {
  // Using reduce for better performance
  return numbers.reduce((sum, num) => sum + num, 0);
}`;
</script>
</body>
</html>
